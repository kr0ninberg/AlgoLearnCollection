# Структуры данных для реализации

## 1. Линейные контейнеры (последовательные)

### Динамический массив (Array List / Vector) - **Средняя сложность**
- **Основа:** Обычный массив, но с автоматическим расширением
- **Ключевые операции:** `push_back`, `pop_back`, `insert`, `erase`, `operator[]` (доступ за O(1)), `resize`
- **Сложности:** Нужно продумать стратегию реаллокации (например, увеличение в 1.5-2 раза)

### Связный список (Linked List) - **Простой**
- **Основа:** Узлы, содержащие данные и указатель на следующий (односвязный) или на следующий и предыдущий (двусвязный) узел
- **Ключевые операции:** `push_front`, `pop_front`, `push_back`, `pop_back`, `insert`, `erase`
- **Ветвление:** Реализуйте односвязный (`forward_list`), затем двусвязный (`list`)

### Стек (Stack) - **Очень простой**
- **Основа:** Не самостоятельный контейнер, а "адаптер". Реализуется поверх динамического массива или связного списка
- **Принцип:** LIFO (Last-In, First-Out)
- **Ключевые операции:** `push`, `pop`, `top`

### Очередь (Queue) - **Очень простой**
- **Основа:** Адаптер, обычно на двусвязном списке или дека
- **Принцип:** FIFO (First-In, First-Out)
- **Ключевые операции:** `push`, `pop`, `front`, `back`

### Дек (Deque - Double Ended Queue) - **Сложный**
- **Основа:** Часто реализуется как массив указателей на фиксированные "блоки" (chunks). Позволяет эффективно добавлять и удалять элементы с обоих концов
- **Ключевые операции:** `push_front`, `pop_front`, `push_back`, `pop_back`

## 2. Ассоциативные контейнеры (основанные на ключах)

### Хеш-таблица (Hash Table / Unordered Map/Set) - **Средняя сложность**
- **Основа:** Массив бакетов (корзин), каждый из которых является списком (или другим контейнером) для разрешения коллизий
- **Ключевые операции:** `insert`, `erase`, `find`
- **Важные аспекты:** Выбор хеш-функции, стратегия разрешения коллизий (метод цепочек самый популярный), рехэширование

### Бинарное дерево поиска (Binary Search Tree - BST) - **Простой**
- **Основа:** Дерево, где у каждого узла не более двух потомков, и для любого узла: левый потомок < узел < правый потомок
- **Примечание:** Это база для более сложных деревьев

### Сбалансированные деревья (AVL Tree, Красно-чёрное дерево) - **Очень сложные**
- **Основа:** BST, которые автоматически балансируются после вставки/удаления, чтобы гарантировать логарифмическую высоту
- **Ключевые операции:** `insert`, `erase`, `find`, а также сложные алгоритмы поворотов и перекрашиваний
- **Применение:** Именно так реализованы `std::map` и `std::set` в C++ (обычно как красно-чёрные деревья)

## 3. Адаптеры и специализированные контейнеры

### Куча (Priority Queue / Heap) - **Средняя сложность**
- **Основа:** Часто реализуется на динамическом массиве, интерпретируемом как бинарное дерево
- **Ключевые операции:** `push`, `pop` (извлечение максимума/минимума), `top`
- **Сложность:** Нужно реализовать алгоритмы "просеивания" (heapify) вверх и вниз

---

# Продвинутые структуры данных

## Распределённые системы и базы данных
### 1. LSM-дерево (Log-Structured Merge-Tree) - **Очень высокая сложность**
- **Где используется:** Cassandra, RocksDB, LevelDB, HBase
- **Суть:** Данные сначала пишутся в лог в памяти (memtable), затем периодически сливаются с дисковыми файлами (SSTables) в фоне. Чтение требует поиска по нескольким уровням
- **Сложные аспекты:** Компактизация, стратегии слияния, bloom-фильтры для ускорения чтения

### 2. CRDT (Conflict-Free Replicated Data Types) - **Экстремальная сложность (теоретическая)**
- **Где используется:** Distributed systems, real-time collaboration (Google Docs, Figma)
- **Суть:** Структуры данных, которые могут реплицироваться и обновляться независимо без координации, гарантируя eventual consistency
- **Примеры:** G-Counters, PN-Counters, OR-Sets

### 3. Merkle Trees - **Высокая сложность**
- **Где используется:** Git, Distributed databases (Dynamo, Cassandra), Blockchain
- **Суть:** Дерево хешей, позволяющее эффективно проверять целостность и синхронизировать большие datasets в распределённых системах

## Графовые базы данных и алгоритмы

### 4. Adjacency Index с компрессией - **Очень высокая сложность**
- **Где используется:** Neo4j, Dgraph, соцсети, рекомендательные системы
- **Суть:** Эффективное хранение графов с миллиардами рёбер, использование техник сжатия (varint encoding, delta encoding)

### 5. HyperLogLog - **Высокая сложность (вероятностная)**
- **Где используется:** Redis, аналитика больших данных, подсчёт уникальных посетителей
- **Суть:** Вероятностная структура для оценки кардинальности множества с минимальным использованием памяти

## Геопространственные данные

### 6. R-дерево (R-Tree) и варианты - **Очень высокая сложность**
- **Где используется:** GIS системы, пространственные базы данных (PostGIS), игры
- **Суть:** Дерево для индексации многомерной информации (координаты, bounding boxes)
- **Варианты:** R*-tree, R+tree, Hilbert R-tree

### 7. Quadtree/Octree - **Высокая сложность**
- **Где используется:** Игры (коллизии, LOD), картография, компьютерная графика
- **Суть:** Рекурсивное разбиение пространства на квадранты/октанты

## Поисковые системы и текстовые индексы

### 8. Суффиксные деревья и массивы - **Экстремальная сложность**
- **Где используется:** Поисковые движки, биоинформатика, анализ генома
- **Суть:** Индекс для быстрого поиска подстрок в большом тексте
- **Альтернативы:** FM-index, сжатые суффиксные массивы

### 9. FST (Finite State Transducers) - **Очень высокая сложность**
- **Где используется:** Lucene/Solr/Elasticsearch, автодополнение, морфологический анализ
- **Суть:** Конечные автоматы, которые одновременно представляют и ключи, и значения с минимальной памятью

## Системы реального времени

### 10. Skip List с lock-free алгоритмами - **Экстремальная сложность**
- **Где используется:** High-frequency trading, real-time databases
- **Суть:** Комбинация вероятностных структур данных с неблокирующими алгоритмами для многопоточности

### 11. Ring Buffer с memory ordering - **Очень высокая сложность**
- **Где используется:** Low-latency systems, packet processing (DPDK)
- **Суть:** Кольцевой буфер с правильными memory barriers для lock-free доступа

## Специализированные структуры

### 12. Judy Arrays - **Экстремальная сложность**
- **Где используется:** Высокопроизводительные системы, где важна и память, и скорость
- **Суть:** Сложная гибридная структура, сочетающая преимущества хеш-таблиц, деревьев и массивов

### 13. Count-Min Sketch - **Высокая сложность (вероятностная)**
- **Где используется:** Streaming algorithms, анализ трафика, trending topics
- **Суть:** Вероятностная структура для оценки частоты элементов в потоке данных

### 14. Bε-tree (B-Epsilon Tree) - **Экстремальная сложность**
- **Где используется:** High-performance databases
- **Суть:** Гибрид B-tree и LSM-tree, оптимизированный для современных storage systems